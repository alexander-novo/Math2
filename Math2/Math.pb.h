// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Math.proto

#ifndef PROTOBUF_Math_2eproto__INCLUDED
#define PROTOBUF_Math_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace MathHelper {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_Math_2eproto();
void protobuf_AssignDesc_Math_2eproto();
void protobuf_ShutdownFile_Math_2eproto();

class Log;
class Log_Session;
class Log_Session_Question;

// ===================================================================

class Log_Session_Question : public ::google::protobuf::Message {
 public:
  Log_Session_Question();
  virtual ~Log_Session_Question();

  Log_Session_Question(const Log_Session_Question& from);

  inline Log_Session_Question& operator=(const Log_Session_Question& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Log_Session_Question& default_instance();

  void Swap(Log_Session_Question* other);

  // implements Message ----------------------------------------------

  inline Log_Session_Question* New() const { return New(NULL); }

  Log_Session_Question* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Log_Session_Question& from);
  void MergeFrom(const Log_Session_Question& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Log_Session_Question* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string time = 1;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  const ::std::string& time() const;
  void set_time(const ::std::string& value);
  void set_time(const char* value);
  void set_time(const char* value, size_t size);
  ::std::string* mutable_time();
  ::std::string* release_time();
  void set_allocated_time(::std::string* time);

  // required int32 x = 2;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 2;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // required int32 y = 3;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 3;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // required string operation = 4;
  bool has_operation() const;
  void clear_operation();
  static const int kOperationFieldNumber = 4;
  const ::std::string& operation() const;
  void set_operation(const ::std::string& value);
  void set_operation(const char* value);
  void set_operation(const char* value, size_t size);
  ::std::string* mutable_operation();
  ::std::string* release_operation();
  void set_allocated_operation(::std::string* operation);

  // repeated string option = 5;
  int option_size() const;
  void clear_option();
  static const int kOptionFieldNumber = 5;
  const ::std::string& option(int index) const;
  ::std::string* mutable_option(int index);
  void set_option(int index, const ::std::string& value);
  void set_option(int index, const char* value);
  void set_option(int index, const char* value, size_t size);
  ::std::string* add_option();
  void add_option(const ::std::string& value);
  void add_option(const char* value);
  void add_option(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& option() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_option();

  // required string answer = 6;
  bool has_answer() const;
  void clear_answer();
  static const int kAnswerFieldNumber = 6;
  const ::std::string& answer() const;
  void set_answer(const ::std::string& value);
  void set_answer(const char* value);
  void set_answer(const char* value, size_t size);
  ::std::string* mutable_answer();
  ::std::string* release_answer();
  void set_allocated_answer(::std::string* answer);

  // repeated int32 attempt = 7;
  int attempt_size() const;
  void clear_attempt();
  static const int kAttemptFieldNumber = 7;
  ::google::protobuf::int32 attempt(int index) const;
  void set_attempt(int index, ::google::protobuf::int32 value);
  void add_attempt(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      attempt() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_attempt();

  // required bool correct = 8;
  bool has_correct() const;
  void clear_correct();
  static const int kCorrectFieldNumber = 8;
  bool correct() const;
  void set_correct(bool value);

  // required double correctPercent = 9;
  bool has_correctpercent() const;
  void clear_correctpercent();
  static const int kCorrectPercentFieldNumber = 9;
  double correctpercent() const;
  void set_correctpercent(double value);

  // @@protoc_insertion_point(class_scope:MathHelper.Log.Session.Question)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_operation();
  inline void clear_has_operation();
  inline void set_has_answer();
  inline void clear_has_answer();
  inline void set_has_correct();
  inline void clear_has_correct();
  inline void set_has_correctpercent();
  inline void clear_has_correctpercent();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr time_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::internal::ArenaStringPtr operation_;
  ::google::protobuf::RepeatedPtrField< ::std::string> option_;
  ::google::protobuf::internal::ArenaStringPtr answer_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > attempt_;
  double correctpercent_;
  bool correct_;
  friend void  protobuf_AddDesc_Math_2eproto();
  friend void protobuf_AssignDesc_Math_2eproto();
  friend void protobuf_ShutdownFile_Math_2eproto();

  void InitAsDefaultInstance();
  static Log_Session_Question* default_instance_;
};
// -------------------------------------------------------------------

class Log_Session : public ::google::protobuf::Message {
 public:
  Log_Session();
  virtual ~Log_Session();

  Log_Session(const Log_Session& from);

  inline Log_Session& operator=(const Log_Session& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Log_Session& default_instance();

  void Swap(Log_Session* other);

  // implements Message ----------------------------------------------

  inline Log_Session* New() const { return New(NULL); }

  Log_Session* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Log_Session& from);
  void MergeFrom(const Log_Session& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Log_Session* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Log_Session_Question Question;

  // accessors -------------------------------------------------------

  // required string startTime = 1;
  bool has_starttime() const;
  void clear_starttime();
  static const int kStartTimeFieldNumber = 1;
  const ::std::string& starttime() const;
  void set_starttime(const ::std::string& value);
  void set_starttime(const char* value);
  void set_starttime(const char* value, size_t size);
  ::std::string* mutable_starttime();
  ::std::string* release_starttime();
  void set_allocated_starttime(::std::string* starttime);

  // required int32 seed = 2;
  bool has_seed() const;
  void clear_seed();
  static const int kSeedFieldNumber = 2;
  ::google::protobuf::int32 seed() const;
  void set_seed(::google::protobuf::int32 value);

  // required int32 difficulty = 3;
  bool has_difficulty() const;
  void clear_difficulty();
  static const int kDifficultyFieldNumber = 3;
  ::google::protobuf::int32 difficulty() const;
  void set_difficulty(::google::protobuf::int32 value);

  // repeated .MathHelper.Log.Session.Question question = 4;
  int question_size() const;
  void clear_question();
  static const int kQuestionFieldNumber = 4;
  const ::MathHelper::Log_Session_Question& question(int index) const;
  ::MathHelper::Log_Session_Question* mutable_question(int index);
  ::MathHelper::Log_Session_Question* add_question();
  ::google::protobuf::RepeatedPtrField< ::MathHelper::Log_Session_Question >*
      mutable_question();
  const ::google::protobuf::RepeatedPtrField< ::MathHelper::Log_Session_Question >&
      question() const;

  // required string endTime = 5;
  bool has_endtime() const;
  void clear_endtime();
  static const int kEndTimeFieldNumber = 5;
  const ::std::string& endtime() const;
  void set_endtime(const ::std::string& value);
  void set_endtime(const char* value);
  void set_endtime(const char* value, size_t size);
  ::std::string* mutable_endtime();
  ::std::string* release_endtime();
  void set_allocated_endtime(::std::string* endtime);

  // @@protoc_insertion_point(class_scope:MathHelper.Log.Session)
 private:
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_seed();
  inline void clear_has_seed();
  inline void set_has_difficulty();
  inline void clear_has_difficulty();
  inline void set_has_endtime();
  inline void clear_has_endtime();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr starttime_;
  ::google::protobuf::int32 seed_;
  ::google::protobuf::int32 difficulty_;
  ::google::protobuf::RepeatedPtrField< ::MathHelper::Log_Session_Question > question_;
  ::google::protobuf::internal::ArenaStringPtr endtime_;
  friend void  protobuf_AddDesc_Math_2eproto();
  friend void protobuf_AssignDesc_Math_2eproto();
  friend void protobuf_ShutdownFile_Math_2eproto();

  void InitAsDefaultInstance();
  static Log_Session* default_instance_;
};
// -------------------------------------------------------------------

class Log : public ::google::protobuf::Message {
 public:
  Log();
  virtual ~Log();

  Log(const Log& from);

  inline Log& operator=(const Log& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Log& default_instance();

  void Swap(Log* other);

  // implements Message ----------------------------------------------

  inline Log* New() const { return New(NULL); }

  Log* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Log& from);
  void MergeFrom(const Log& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Log* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Log_Session Session;

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional bool hasSeenHelp = 2 [default = false];
  bool has_hasseenhelp() const;
  void clear_hasseenhelp();
  static const int kHasSeenHelpFieldNumber = 2;
  bool hasseenhelp() const;
  void set_hasseenhelp(bool value);

  // repeated .MathHelper.Log.Session session = 3;
  int session_size() const;
  void clear_session();
  static const int kSessionFieldNumber = 3;
  const ::MathHelper::Log_Session& session(int index) const;
  ::MathHelper::Log_Session* mutable_session(int index);
  ::MathHelper::Log_Session* add_session();
  ::google::protobuf::RepeatedPtrField< ::MathHelper::Log_Session >*
      mutable_session();
  const ::google::protobuf::RepeatedPtrField< ::MathHelper::Log_Session >&
      session() const;

  // @@protoc_insertion_point(class_scope:MathHelper.Log)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_hasseenhelp();
  inline void clear_has_hasseenhelp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::RepeatedPtrField< ::MathHelper::Log_Session > session_;
  bool hasseenhelp_;
  friend void  protobuf_AddDesc_Math_2eproto();
  friend void protobuf_AssignDesc_Math_2eproto();
  friend void protobuf_ShutdownFile_Math_2eproto();

  void InitAsDefaultInstance();
  static Log* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Log_Session_Question

// required string time = 1;
inline bool Log_Session_Question::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Log_Session_Question::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Log_Session_Question::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Log_Session_Question::clear_time() {
  time_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_time();
}
inline const ::std::string& Log_Session_Question::time() const {
  // @@protoc_insertion_point(field_get:MathHelper.Log.Session.Question.time)
  return time_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Log_Session_Question::set_time(const ::std::string& value) {
  set_has_time();
  time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MathHelper.Log.Session.Question.time)
}
inline void Log_Session_Question::set_time(const char* value) {
  set_has_time();
  time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MathHelper.Log.Session.Question.time)
}
inline void Log_Session_Question::set_time(const char* value, size_t size) {
  set_has_time();
  time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MathHelper.Log.Session.Question.time)
}
inline ::std::string* Log_Session_Question::mutable_time() {
  set_has_time();
  // @@protoc_insertion_point(field_mutable:MathHelper.Log.Session.Question.time)
  return time_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Log_Session_Question::release_time() {
  clear_has_time();
  return time_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Log_Session_Question::set_allocated_time(::std::string* time) {
  if (time != NULL) {
    set_has_time();
  } else {
    clear_has_time();
  }
  time_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), time);
  // @@protoc_insertion_point(field_set_allocated:MathHelper.Log.Session.Question.time)
}

// required int32 x = 2;
inline bool Log_Session_Question::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Log_Session_Question::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Log_Session_Question::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Log_Session_Question::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 Log_Session_Question::x() const {
  // @@protoc_insertion_point(field_get:MathHelper.Log.Session.Question.x)
  return x_;
}
inline void Log_Session_Question::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:MathHelper.Log.Session.Question.x)
}

// required int32 y = 3;
inline bool Log_Session_Question::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Log_Session_Question::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Log_Session_Question::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Log_Session_Question::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 Log_Session_Question::y() const {
  // @@protoc_insertion_point(field_get:MathHelper.Log.Session.Question.y)
  return y_;
}
inline void Log_Session_Question::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:MathHelper.Log.Session.Question.y)
}

// required string operation = 4;
inline bool Log_Session_Question::has_operation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Log_Session_Question::set_has_operation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Log_Session_Question::clear_has_operation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Log_Session_Question::clear_operation() {
  operation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_operation();
}
inline const ::std::string& Log_Session_Question::operation() const {
  // @@protoc_insertion_point(field_get:MathHelper.Log.Session.Question.operation)
  return operation_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Log_Session_Question::set_operation(const ::std::string& value) {
  set_has_operation();
  operation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MathHelper.Log.Session.Question.operation)
}
inline void Log_Session_Question::set_operation(const char* value) {
  set_has_operation();
  operation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MathHelper.Log.Session.Question.operation)
}
inline void Log_Session_Question::set_operation(const char* value, size_t size) {
  set_has_operation();
  operation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MathHelper.Log.Session.Question.operation)
}
inline ::std::string* Log_Session_Question::mutable_operation() {
  set_has_operation();
  // @@protoc_insertion_point(field_mutable:MathHelper.Log.Session.Question.operation)
  return operation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Log_Session_Question::release_operation() {
  clear_has_operation();
  return operation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Log_Session_Question::set_allocated_operation(::std::string* operation) {
  if (operation != NULL) {
    set_has_operation();
  } else {
    clear_has_operation();
  }
  operation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), operation);
  // @@protoc_insertion_point(field_set_allocated:MathHelper.Log.Session.Question.operation)
}

// repeated string option = 5;
inline int Log_Session_Question::option_size() const {
  return option_.size();
}
inline void Log_Session_Question::clear_option() {
  option_.Clear();
}
inline const ::std::string& Log_Session_Question::option(int index) const {
  // @@protoc_insertion_point(field_get:MathHelper.Log.Session.Question.option)
  return option_.Get(index);
}
inline ::std::string* Log_Session_Question::mutable_option(int index) {
  // @@protoc_insertion_point(field_mutable:MathHelper.Log.Session.Question.option)
  return option_.Mutable(index);
}
inline void Log_Session_Question::set_option(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:MathHelper.Log.Session.Question.option)
  option_.Mutable(index)->assign(value);
}
inline void Log_Session_Question::set_option(int index, const char* value) {
  option_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:MathHelper.Log.Session.Question.option)
}
inline void Log_Session_Question::set_option(int index, const char* value, size_t size) {
  option_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MathHelper.Log.Session.Question.option)
}
inline ::std::string* Log_Session_Question::add_option() {
  return option_.Add();
}
inline void Log_Session_Question::add_option(const ::std::string& value) {
  option_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:MathHelper.Log.Session.Question.option)
}
inline void Log_Session_Question::add_option(const char* value) {
  option_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:MathHelper.Log.Session.Question.option)
}
inline void Log_Session_Question::add_option(const char* value, size_t size) {
  option_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:MathHelper.Log.Session.Question.option)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Log_Session_Question::option() const {
  // @@protoc_insertion_point(field_list:MathHelper.Log.Session.Question.option)
  return option_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Log_Session_Question::mutable_option() {
  // @@protoc_insertion_point(field_mutable_list:MathHelper.Log.Session.Question.option)
  return &option_;
}

// required string answer = 6;
inline bool Log_Session_Question::has_answer() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Log_Session_Question::set_has_answer() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Log_Session_Question::clear_has_answer() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Log_Session_Question::clear_answer() {
  answer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_answer();
}
inline const ::std::string& Log_Session_Question::answer() const {
  // @@protoc_insertion_point(field_get:MathHelper.Log.Session.Question.answer)
  return answer_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Log_Session_Question::set_answer(const ::std::string& value) {
  set_has_answer();
  answer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MathHelper.Log.Session.Question.answer)
}
inline void Log_Session_Question::set_answer(const char* value) {
  set_has_answer();
  answer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MathHelper.Log.Session.Question.answer)
}
inline void Log_Session_Question::set_answer(const char* value, size_t size) {
  set_has_answer();
  answer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MathHelper.Log.Session.Question.answer)
}
inline ::std::string* Log_Session_Question::mutable_answer() {
  set_has_answer();
  // @@protoc_insertion_point(field_mutable:MathHelper.Log.Session.Question.answer)
  return answer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Log_Session_Question::release_answer() {
  clear_has_answer();
  return answer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Log_Session_Question::set_allocated_answer(::std::string* answer) {
  if (answer != NULL) {
    set_has_answer();
  } else {
    clear_has_answer();
  }
  answer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), answer);
  // @@protoc_insertion_point(field_set_allocated:MathHelper.Log.Session.Question.answer)
}

// repeated int32 attempt = 7;
inline int Log_Session_Question::attempt_size() const {
  return attempt_.size();
}
inline void Log_Session_Question::clear_attempt() {
  attempt_.Clear();
}
inline ::google::protobuf::int32 Log_Session_Question::attempt(int index) const {
  // @@protoc_insertion_point(field_get:MathHelper.Log.Session.Question.attempt)
  return attempt_.Get(index);
}
inline void Log_Session_Question::set_attempt(int index, ::google::protobuf::int32 value) {
  attempt_.Set(index, value);
  // @@protoc_insertion_point(field_set:MathHelper.Log.Session.Question.attempt)
}
inline void Log_Session_Question::add_attempt(::google::protobuf::int32 value) {
  attempt_.Add(value);
  // @@protoc_insertion_point(field_add:MathHelper.Log.Session.Question.attempt)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Log_Session_Question::attempt() const {
  // @@protoc_insertion_point(field_list:MathHelper.Log.Session.Question.attempt)
  return attempt_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Log_Session_Question::mutable_attempt() {
  // @@protoc_insertion_point(field_mutable_list:MathHelper.Log.Session.Question.attempt)
  return &attempt_;
}

// required bool correct = 8;
inline bool Log_Session_Question::has_correct() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Log_Session_Question::set_has_correct() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Log_Session_Question::clear_has_correct() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Log_Session_Question::clear_correct() {
  correct_ = false;
  clear_has_correct();
}
inline bool Log_Session_Question::correct() const {
  // @@protoc_insertion_point(field_get:MathHelper.Log.Session.Question.correct)
  return correct_;
}
inline void Log_Session_Question::set_correct(bool value) {
  set_has_correct();
  correct_ = value;
  // @@protoc_insertion_point(field_set:MathHelper.Log.Session.Question.correct)
}

// required double correctPercent = 9;
inline bool Log_Session_Question::has_correctpercent() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Log_Session_Question::set_has_correctpercent() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Log_Session_Question::clear_has_correctpercent() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Log_Session_Question::clear_correctpercent() {
  correctpercent_ = 0;
  clear_has_correctpercent();
}
inline double Log_Session_Question::correctpercent() const {
  // @@protoc_insertion_point(field_get:MathHelper.Log.Session.Question.correctPercent)
  return correctpercent_;
}
inline void Log_Session_Question::set_correctpercent(double value) {
  set_has_correctpercent();
  correctpercent_ = value;
  // @@protoc_insertion_point(field_set:MathHelper.Log.Session.Question.correctPercent)
}

// -------------------------------------------------------------------

// Log_Session

// required string startTime = 1;
inline bool Log_Session::has_starttime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Log_Session::set_has_starttime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Log_Session::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Log_Session::clear_starttime() {
  starttime_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_starttime();
}
inline const ::std::string& Log_Session::starttime() const {
  // @@protoc_insertion_point(field_get:MathHelper.Log.Session.startTime)
  return starttime_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Log_Session::set_starttime(const ::std::string& value) {
  set_has_starttime();
  starttime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MathHelper.Log.Session.startTime)
}
inline void Log_Session::set_starttime(const char* value) {
  set_has_starttime();
  starttime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MathHelper.Log.Session.startTime)
}
inline void Log_Session::set_starttime(const char* value, size_t size) {
  set_has_starttime();
  starttime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MathHelper.Log.Session.startTime)
}
inline ::std::string* Log_Session::mutable_starttime() {
  set_has_starttime();
  // @@protoc_insertion_point(field_mutable:MathHelper.Log.Session.startTime)
  return starttime_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Log_Session::release_starttime() {
  clear_has_starttime();
  return starttime_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Log_Session::set_allocated_starttime(::std::string* starttime) {
  if (starttime != NULL) {
    set_has_starttime();
  } else {
    clear_has_starttime();
  }
  starttime_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), starttime);
  // @@protoc_insertion_point(field_set_allocated:MathHelper.Log.Session.startTime)
}

// required int32 seed = 2;
inline bool Log_Session::has_seed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Log_Session::set_has_seed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Log_Session::clear_has_seed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Log_Session::clear_seed() {
  seed_ = 0;
  clear_has_seed();
}
inline ::google::protobuf::int32 Log_Session::seed() const {
  // @@protoc_insertion_point(field_get:MathHelper.Log.Session.seed)
  return seed_;
}
inline void Log_Session::set_seed(::google::protobuf::int32 value) {
  set_has_seed();
  seed_ = value;
  // @@protoc_insertion_point(field_set:MathHelper.Log.Session.seed)
}

// required int32 difficulty = 3;
inline bool Log_Session::has_difficulty() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Log_Session::set_has_difficulty() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Log_Session::clear_has_difficulty() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Log_Session::clear_difficulty() {
  difficulty_ = 0;
  clear_has_difficulty();
}
inline ::google::protobuf::int32 Log_Session::difficulty() const {
  // @@protoc_insertion_point(field_get:MathHelper.Log.Session.difficulty)
  return difficulty_;
}
inline void Log_Session::set_difficulty(::google::protobuf::int32 value) {
  set_has_difficulty();
  difficulty_ = value;
  // @@protoc_insertion_point(field_set:MathHelper.Log.Session.difficulty)
}

// repeated .MathHelper.Log.Session.Question question = 4;
inline int Log_Session::question_size() const {
  return question_.size();
}
inline void Log_Session::clear_question() {
  question_.Clear();
}
inline const ::MathHelper::Log_Session_Question& Log_Session::question(int index) const {
  // @@protoc_insertion_point(field_get:MathHelper.Log.Session.question)
  return question_.Get(index);
}
inline ::MathHelper::Log_Session_Question* Log_Session::mutable_question(int index) {
  // @@protoc_insertion_point(field_mutable:MathHelper.Log.Session.question)
  return question_.Mutable(index);
}
inline ::MathHelper::Log_Session_Question* Log_Session::add_question() {
  // @@protoc_insertion_point(field_add:MathHelper.Log.Session.question)
  return question_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::MathHelper::Log_Session_Question >*
Log_Session::mutable_question() {
  // @@protoc_insertion_point(field_mutable_list:MathHelper.Log.Session.question)
  return &question_;
}
inline const ::google::protobuf::RepeatedPtrField< ::MathHelper::Log_Session_Question >&
Log_Session::question() const {
  // @@protoc_insertion_point(field_list:MathHelper.Log.Session.question)
  return question_;
}

// required string endTime = 5;
inline bool Log_Session::has_endtime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Log_Session::set_has_endtime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Log_Session::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Log_Session::clear_endtime() {
  endtime_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_endtime();
}
inline const ::std::string& Log_Session::endtime() const {
  // @@protoc_insertion_point(field_get:MathHelper.Log.Session.endTime)
  return endtime_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Log_Session::set_endtime(const ::std::string& value) {
  set_has_endtime();
  endtime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MathHelper.Log.Session.endTime)
}
inline void Log_Session::set_endtime(const char* value) {
  set_has_endtime();
  endtime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MathHelper.Log.Session.endTime)
}
inline void Log_Session::set_endtime(const char* value, size_t size) {
  set_has_endtime();
  endtime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MathHelper.Log.Session.endTime)
}
inline ::std::string* Log_Session::mutable_endtime() {
  set_has_endtime();
  // @@protoc_insertion_point(field_mutable:MathHelper.Log.Session.endTime)
  return endtime_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Log_Session::release_endtime() {
  clear_has_endtime();
  return endtime_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Log_Session::set_allocated_endtime(::std::string* endtime) {
  if (endtime != NULL) {
    set_has_endtime();
  } else {
    clear_has_endtime();
  }
  endtime_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), endtime);
  // @@protoc_insertion_point(field_set_allocated:MathHelper.Log.Session.endTime)
}

// -------------------------------------------------------------------

// Log

// required string name = 1;
inline bool Log::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Log::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Log::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Log::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Log::name() const {
  // @@protoc_insertion_point(field_get:MathHelper.Log.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Log::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MathHelper.Log.name)
}
inline void Log::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MathHelper.Log.name)
}
inline void Log::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MathHelper.Log.name)
}
inline ::std::string* Log::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:MathHelper.Log.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Log::release_name() {
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Log::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:MathHelper.Log.name)
}

// optional bool hasSeenHelp = 2 [default = false];
inline bool Log::has_hasseenhelp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Log::set_has_hasseenhelp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Log::clear_has_hasseenhelp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Log::clear_hasseenhelp() {
  hasseenhelp_ = false;
  clear_has_hasseenhelp();
}
inline bool Log::hasseenhelp() const {
  // @@protoc_insertion_point(field_get:MathHelper.Log.hasSeenHelp)
  return hasseenhelp_;
}
inline void Log::set_hasseenhelp(bool value) {
  set_has_hasseenhelp();
  hasseenhelp_ = value;
  // @@protoc_insertion_point(field_set:MathHelper.Log.hasSeenHelp)
}

// repeated .MathHelper.Log.Session session = 3;
inline int Log::session_size() const {
  return session_.size();
}
inline void Log::clear_session() {
  session_.Clear();
}
inline const ::MathHelper::Log_Session& Log::session(int index) const {
  // @@protoc_insertion_point(field_get:MathHelper.Log.session)
  return session_.Get(index);
}
inline ::MathHelper::Log_Session* Log::mutable_session(int index) {
  // @@protoc_insertion_point(field_mutable:MathHelper.Log.session)
  return session_.Mutable(index);
}
inline ::MathHelper::Log_Session* Log::add_session() {
  // @@protoc_insertion_point(field_add:MathHelper.Log.session)
  return session_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::MathHelper::Log_Session >*
Log::mutable_session() {
  // @@protoc_insertion_point(field_mutable_list:MathHelper.Log.session)
  return &session_;
}
inline const ::google::protobuf::RepeatedPtrField< ::MathHelper::Log_Session >&
Log::session() const {
  // @@protoc_insertion_point(field_list:MathHelper.Log.session)
  return session_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace MathHelper

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Math_2eproto__INCLUDED
